# Undercover Scrum Master


## Prior Operations

* Software development since 2009 (PO, BA, AO, etc.).
* Part-time Scrum Master starting in 2013.
* Full-time Scrum Master/Agile Coach from January 2016 until...
* Ruby developer on Scrum team starting August 2017.


## Mission Background

* Since discovering the Agile world, I've always been my team's Scrum Master or Agile Coach.
* I have always written scripts and queries to make my job easier, but hadn't contributed to a shared codebase.


## Mission Objective

Gain full-time experience writing production code on an Agile software developer team.

---

## Mission Debrief

1. Writing code = fun
2. Test infrasctructure != fun
3. Implicitly in a hurry
4. Cognitive load
5. Big picture paradox
6. "Pairing," pairing, and Pairing

---

## 1. Writing code = fun

Feedback loops are gratifying

Note:
* Seeing someone use the software
* Demoing to a stakeholder
* Tester approval
* Seeing the software work
* Getting automated tests to pass


### "Flow"


### Test-Driven Development

* Feels great when you're thinking about the production code.
* Feels like a waste when you're thinking about the tests.

---

## 2. Test infrastructure <br/> != <br/> fun


### Creating & maintaining test infrastructure is a necessary chore

* It's easier when it grows with the product
* Testing a simple function is simple
* Testing the whole application isn't bad, once you figure out your testing framework
* Tests in the middle are the messiest


### Messy tests

* Test doubles (mocks) help run tests more quickly (good) and with a narrower focus (also good)
* Test doubles requires knowing about how remote parts of the application work
* Figuring out the required test doubles for poorly-tested existing code is a royal pain
* Poorly tested code discourages new tests

---

## 3. Implicitly in a hurry

Unauthorized technical debt


### Velocity/Cycle Time

* Of course we want to deliver more faster always
* POs and stakeholders only ask for more faster
* Quality only seems to matter when a defect escapes
* It's hard to communicate how code quality needs to be improved
* Writing high-quality code can end up being a matter of self-discipline with minimal support


### Recommendations for better quality

* Clearly communicate the team's commitment not to cut corners
* Shield the team from hurry-up talk
* Be very clear when an immediate band-aid is needed, to be followed later by a good fix
* Taking on technical debt should be rare and only when explicitly demanded in writing by the PO

---

## 4. Cognitive load

We get tired


### So much to know and think about

* So many tools, languages, & responsibilities
* Need to know business, technology, and process
* This load gets even worse in a "scaled" scenario

---

## 5. Big picture paradox


### Conflicting Motivations

Gain context, avoid waste, and guide product

vs.

Have fun programming, minimize cognitive load, address urgent needs

Note:
* Need the big picture for executive decision-making
* Want early input to avoid bad path dependency
* Also want to focus on the work-at-hand (fun feedback loops)
* And want to reduce cognitive load

---

## 6. "Pairing," pairing, and Pairing

Note:
1. Working in close collaboration.
2. Only one person coding at a time, but driving for a _long_ time.
3. Actually switching off coding at same computer.


![747 cockpit with same controls for each side](747-cockpit.jpg)

Note:
* How much time do you want to spend switching between drivers?


### Friction
1. Desk space
2. Hardware/software
3. Habits & intuition
4. Social comfort
5. Skill

Note:
* Full pairing takes infrastructure (hardware/screeshare) and courage
* Not intuitive and generally not comfortable
* Even close collaboration is a skill and not guaranteed to succeed

---

## Conclusion

<img src="noun_Detective_1098021.svg" alt="more info" class="plain" style="background: none" width="8%" />

---

## Bonus: the CSD

* CSM + three days of Agile engineering
* Hands-on TDD
* All about automated tests
* SOLID design principles
* Clean code
* A little about pairing